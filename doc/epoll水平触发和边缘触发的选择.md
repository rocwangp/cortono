# epoll水平触发和边缘触发的选择

epoll中有两种触发模式，一种是水平触发（LT），另一种是边缘触发（ET），二者的区别在于事件的二次触发问题

## 可读事件

以可读事件为例，假设当前接收缓冲区中有500字节的数据可读，那么当io复用函数返回后执行可读回调函数时

对于水平触发，如果函数仅仅接收了400字节就返回，那么回到io复用时套接字仍然是可读的，会立即返回然后继续执行可读回调

对于边缘触发，对于相同数据的可读状态仅通知一次，也就是说即使在可读回调函数中没有接收全部的数据，下次回到io复用时套接字的可读状态已经消失，会等到再有新数据到达时再提示可读。对于上面的例子，如果之后再也没有数据到来，那么剩下的100字节将会丢失

综上，对于读事件而言

- 水平触发不容易出现数据的丢失，直到将数据全部接收后套接字的可读状态才消失
- 边缘触发容易出现数据的丢失，因为可读状态仅在当次返回有效

所以对于采用边缘触发的框架而言，通常都有必要设计应用层的缓冲区，保证在可读回调函数中将接收缓冲区的数据全部接收以防止数据的丢失



## 可写事件

以可写事件为例，当网络流量很大，从服务器发送的数据特别多时，由于发送缓冲区大小固定，所以通常情况下都是分多次发送。假设发送缓冲区为200M，服务器要发送1G的数据，那么就需要分5次发送，每次发送200M（通常情况下是一有空间就写入数据，这里为了解释清楚，假设每次发送200M）

对于水平触发，当准备发送1G的数据却发现实际仅发送了200M的数据时，就需要开启套接字的可写事件，同时注册可写回调，等到发送缓冲区存在空间时继续发送剩下的数据。当1G的数据都发送完毕后，需要关闭可写事件的监听，否则当发送完毕，发送缓冲区会一直存在空闲空间，也就是一直可写，那么对于水平触发就会一直触发可写事件

对于边缘触发，程序可以在创建连接对象时就将可写事件的监听打开，由于边缘触发仅触发一次，即使当前可写，由于没有数据可以发送，可写回调不做任何事情回到io复用中。等到需要发送1G数据却发送仅发送了200M时，io复用会重新刷新套接字的可写事件，等到发送缓冲区有空间时再次触发可写事件。等到全部数据发送完毕后也无需关闭可写事件的监听

综上，对于写事件而言

- 水平触发需要频繁打开和关闭EPOLLOUT选项
- 边缘触发只需要在创建连接对象时打开EPOLLOUT，后续无需关闭，因为只触发一次

所以对于网络流量很大的服务器而言，采用边缘触发可以避免频发打开和关闭EPOLLOUT选项的开销，使得程序更易于管理

------

边缘触发接收/发送数据的完整代码[参考这里](https://github.com/rocwangp/cortono/blob/master/net/connection.hpp#L201)

