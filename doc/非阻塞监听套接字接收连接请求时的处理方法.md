# 非阻塞监听套接字接收连接请求时的处理方法

## 循环接收代替一次一个接收

按照惯例，当监听套接字变为可读时，一定需要执行处理函数去接收客户端的连接请求，当接收完成后回到io复用函数中继续等待下一个请求的到来

从TCP/IP协议栈的连接缓冲区的角度观察，协议栈中实际上维护了一个连接队列，每当有一个客户端请求连接到目标服务器，在目标服务器的连接队列中就会追加一个连接请求，这一步也就触发了监听套接字的可读事件。而当程序执行accept接收一个客户端连接时，实际上也就是从连接队列的队首取出一个连接请求

但是当遇到密集连接的情况时，程序在进入到处理函数中时连接队列可能已经存在了多个连接请求，那如果程序每次只接收一个连接，程序的执行流程大致如下

- io复用函数等待监听套接字可读
- 执行回调函数，接收一个客户端连接请求
- 回到io复用函数，由于连接队列中仍然有连接请求，所以io复用立即返回
- 执行回调函数，接收一个客户端连接请求
- 回到io复用函数，如果连接队列仍然非空，则立即返回
- ...

由于每次仅接收一个连接请求，导致程序做了很多无用功，解决方法就是在回调函数中将所有的客户端连接都接收完再返回到io复用函数中，但是这又有一个问题，因为需要在while循环中不断接收，所以监听套接字必须设置成非阻塞，当accept返回-1时方可跳出循环，回到io复用中。否则一旦没有连接可以接收，程序就会阻塞在accept上

代码片段如下

```c++
while(true) {
    int fd = socket_.accept();
    if(fd == -1) {
        break;
    }
    ...//创建连接对象
}
```

## 文件描述符耗尽的解决办法

由三次握手的流程可知，在最后一个握手阶段，accept函数实际上做了两件事情

- 选择一个空闲的文件描述符作为连接套接字
- 从任务队列中取出一个连接请求，绑定到选择的套接字上

那么当本地文件描述符耗尽时，accpet根本无法将连接请求取出，导致连接一直停留在连接队列中无法关闭，此时客户端实际上已经认为连接建立完成（因为第二次握手结束connect就已经返回），而服务器根据就没有建立连接（第三次握手时accept失败）

所以需要想办法将这个连接请求取出，然后优雅的关闭掉。方法就是在程序启动时预先占用一个空闲描述符，记作idle_fd_，当出现上述情况时，将idle\_fd\_关掉，此时就会出现一个空闲描述符，再次调用accept一定能够成功接收，随后立即将接收到的连接关掉，然后再次占用空闲描述符

代码片段如下

```c++
int fd = socket_.accept();
if(fd == -1) {
	// EMFILE是文件描述符耗尽的错误码
    if(errno == EMFILE) {
        close(idle_fd_);
        fd = socket_.accept();
        close(fd);
        idle_fd_ = open("dev/null");
    }
}
```

完整代码[参考这里](https://github.com/rocwangp/cortono/blob/master/net/adaptor.hpp#L38)

