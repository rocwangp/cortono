<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Redis," />


<meta name="description" content="Redis提供了订阅和发布的功能，允许客户端订阅一个或多个频道，当其他客户端向某个频道发送消息时，服务器会将消息转发给所有订阅该频道的客户端 这一点有点像群聊的功能，一个客户端将消息发往群中(向某个频道发送消息)，所有在群中的客户端(订阅该频道的客户端)都会收到这个消息。事实也正是如此，接下来将会看到，服务器采用字典保存每个频道(键)和订阅该频道的所有客户端(值)，每当其他客户端向某个频道发送消息">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码剖析（五）订阅与发布">
<meta property="og:url" content="http://yoursite.com/2018/01/05/Redis源码剖析（五）订阅与发布/index.html">
<meta property="og:site_name" content="「.Roc.」">
<meta property="og:description" content="Redis提供了订阅和发布的功能，允许客户端订阅一个或多个频道，当其他客户端向某个频道发送消息时，服务器会将消息转发给所有订阅该频道的客户端 这一点有点像群聊的功能，一个客户端将消息发往群中(向某个频道发送消息)，所有在群中的客户端(订阅该频道的客户端)都会收到这个消息。事实也正是如此，接下来将会看到，服务器采用字典保存每个频道(键)和订阅该频道的所有客户端(值)，每当其他客户端向某个频道发送消息">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-19T07:02:23.481Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis源码剖析（五）订阅与发布">
<meta name="twitter:description" content="Redis提供了订阅和发布的功能，允许客户端订阅一个或多个频道，当其他客户端向某个频道发送消息时，服务器会将消息转发给所有订阅该频道的客户端 这一点有点像群聊的功能，一个客户端将消息发往群中(向某个频道发送消息)，所有在群中的客户端(订阅该频道的客户端)都会收到这个消息。事实也正是如此，接下来将会看到，服务器采用字典保存每个频道(键)和订阅该频道的所有客户端(值)，每当其他客户端向某个频道发送消息">






  <link rel="canonical" href="http://yoursite.com/2018/01/05/Redis源码剖析（五）订阅与发布/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>Redis源码剖析（五）订阅与发布 | 「.Roc.」</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">「.Roc.」</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/05/Redis源码剖析（五）订阅与发布/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="「.Roc.」">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis源码剖析（五）订阅与发布</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T16:33:00+08:00">2018-01-05</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Redis提供了订阅和发布的功能，允许客户端订阅一个或多个频道，当其他客户端向某个频道发送消息时，服务器会将消息转发给所有订阅该频道的客户端</p>
<p>这一点有点像群聊的功能，一个客户端将消息发往群中(向某个频道发送消息)，所有在群中的客户端(订阅该频道的客户端)都会收到这个消息。事实也正是如此，接下来将会看到，服务器采用字典保存每个频道(键)和订阅该频道的所有客户端(值)，每当其他客户端向某个频道发送消息时，服务器便从字典中获取所有订阅该频道的客户端，依次将消息发送。每个频道，可以看成是每个群，一个频道的所有订阅客户端，可以看成该群的所有群成员，唯一不同的是，向频道发送消息的那个客户端并不需要订阅同样的频道，也就是该客户端并不需要也在群中</p>
<p>稍后会看到，除了订阅特定频道，Redis也允许客户端进行模式订阅，即一次订阅所有匹配的频道</p>
<a id="more"></a>
<p>Redis的订阅与发布功能由PUBLISH, SUBSCRIBE, PSUBSCRIBE等命令组成</p>
<h1 id="普通订阅"><a href="#普通订阅" class="headerlink" title="普通订阅"></a>普通订阅</h1><p>使用SUBSCRIBE [频道名]即可订阅特定频道，频道名可以自定义，也可以同时订阅多个频道，只需要后面添加多个频道名即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE <span class="string">"news.redis"</span>	<span class="comment">//订阅"news.redis"频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span>	<span class="comment">//命令关键字</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"news.redis"</span>	<span class="comment">//频道名</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span>	<span class="comment">//订阅该频道的客户端数量</span></span><br></pre></td></tr></table></figure>
<p>使用PUBLISH [频道名] [消息]即可向特定频道发送消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PUBLISH <span class="string">"news.redis"</span> <span class="string">"send a message"</span>	<span class="comment">//向"news.redis"频道发送消息</span></span><br><span class="line">(integer) <span class="number">1</span>	<span class="comment">//返回发送给了多少个客户端</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>此时，如果再查看订阅news.redis频道的那个客户端，会发现终端上打印出”send a message”信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PUBLISH之前</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE <span class="string">"news.redis"</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"news.redis"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PUBLISH之后</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"message"</span>	<span class="comment">//消息类型</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"news.redis"</span>	<span class="comment">//频道名</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"send a message"</span>	<span class="comment">//信息</span></span><br></pre></td></tr></table></figure>
<p>不过如果一个客户端处于订阅状态，它好像就不能执行其他操作了</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>实现一个订阅与发布功能十分简单，开篇也提到了，只需要将每个频道以及它的订阅者记录在字典中，如果客户端向某个频道发送消息，则在字典中查找该频道的所有订阅者，依次将消息发送过去即可。</p>
<p>在深入源代码之前，先看两个结构的定义，一个是客户端，一个是服务器，它们都定义在server.h头文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">    dict *pubsub_channels; </span><br><span class="line">    ...</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">    dict *pubsub_channels;  </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这两个结构都太长了，不过目前用得到的其实就一个pubsub_channels变量，根据类型得知该变量是一个字典(以下简称为订阅字典)，两个变量的作用分别是</p>
<ul>
<li>客户端的订阅字典记录着当前客户端订阅的所有频道，键是频道名，值为空</li>
<li>服务器的订阅字典记录着所有频道以及每个频道的订阅者，键是频道名，值是客户端链表</li>
</ul>
<p>到这里其实可以简单猜测订阅功能是如何实现的，当某个客户端使用SUBSCRIBE命令订阅一个或多个频道时，Redis会将&lt;频道名，客户端&gt;这个键值对添加到服务器的订阅字典中，同时也会将频道名添加到客户端自己的订阅字典中</p>
<p>而当客户端使用PUBLISH命令向某个频道发送消息时，Redis会在订阅字典中获取该频道的所有订阅者(客户端)，依次将消息发送给客户端。如果该频道不存在或没有订阅者，则不执行任何操作</p>
<h2 id="订阅功能"><a href="#订阅功能" class="headerlink" title="订阅功能"></a>订阅功能</h2><p>订阅功能由subscribeCommand函数完成，函数主要任务是遍历每一参数(频道名)，调用pubsubSubscribeChannel函数将频道名和客户端添加到订阅字典中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* 订阅命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将客户端和它订阅的频道进行关联，添加到订阅字典中</span></span><br><span class="line"><span class="comment">     * 键是频道名，值是客户端 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</span><br><span class="line">    <span class="comment">/* 标记当前客户端订阅过某些频道 */</span></span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pubsubSubscribeChannel函数完成实际的添加操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将客户端和它订阅的频道进行关联，添加到客户端和服务器两个订阅字典中 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注：服务器和客户端都有订阅字典，分别是</span></span><br><span class="line"><span class="comment"> * c-&gt;pubsub_channels</span></span><br><span class="line"><span class="comment"> * server.pubsub_channels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(client *c, robj *channel)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断当前客户端是否已经订阅了该频道，如果是则不进行处理，否则添加到客户端的订阅字典中 */</span></span><br><span class="line">    <span class="comment">/* 注意这里添加的是客户端的订阅字典，该字典记录当前客户端订阅的所有频道 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 所有的robj对象都是基于引用计数的，因为已将其添加到字典中，所有引用计数加一 */</span></span><br><span class="line">        incrRefCount(channel);</span><br><span class="line">        <span class="comment">/* 从服务器的订阅字典中寻找该频道对应的键节点链表(记录所有订阅该频道的客户端链表) */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* 服务器订阅字典中没有关于该频道的记录，创建该频道对应的客户端链表 */</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            <span class="comment">/* 将&lt;频道，客户端链表&gt;添加到服务器的订阅字典中 */</span></span><br><span class="line">            dictAdd(server.pubsub_channels,channel,clients);</span><br><span class="line">            <span class="comment">/* 频道的引用计数加一 ，因为在字典中也有一份*/</span></span><br><span class="line">            incrRefCount(channel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 服务器订阅字典中有关于该频道的记录，直接将客户端链表返回 */</span> </span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将当前客户端连接到链表上 */</span></span><br><span class="line">        listAddNodeTail(clients,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 通知客户端订阅成功 */</span> </span><br><span class="line">    addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</span><br><span class="line">    addReply(c,shared.subscribebulk);</span><br><span class="line">    addReplyBulk(c,channel);</span><br><span class="line">    addReplyLongLong(c,clientSubscriptionsCount(c));</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此订阅操作完成，可以发现订阅仅仅是将频道名和客户端这个键值对添加到订阅字典中，并不执行其他操作。</p>
<h2 id="退订功能"><a href="#退订功能" class="headerlink" title="退订功能"></a>退订功能</h2><p>有订阅就有退订，退订命令是UNSUBSCRIBE，有unsubscribeCommand函数执行。不过既然订阅功能是阻塞的，怎么执行退订啊…</p>
<p>退订分两种，一种是退订当前客户端订阅的所有频道，此时退订命令不带参数。另一种则带参数，仅退订参数指出的频道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* 退订命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 退订当前客户端订阅的所有频道 */</span></span><br><span class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 退订参数指出的频道 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 客户端订阅的频道数为0时，改变标志 */</span></span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退订所有频道是遍历当前客户端的订阅字典，对订阅的每个频道调用pubsubUnsubscribeChannel函数，实际上和指定参数效果相同，所以就直接看退订参数指定频道的函数好了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 退订</span></span><br><span class="line"><span class="comment"> * c : 客户端</span></span><br><span class="line"><span class="comment"> * channel : 要退订的频道</span></span><br><span class="line"><span class="comment"> * notify : 退订后是否通知客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(client *c, robj *channel, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    incrRefCount(channel); <span class="comment">/* channel may be just a pointer to the same object</span></span><br><span class="line"><span class="comment">                            we have in the hash tables. Protect it... */</span></span><br><span class="line">    <span class="comment">/* 从客户端订阅字典中删除关于该频道的订阅信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</span><br><span class="line">        <span class="comment">/* 删除成功，表示这个客户端订阅过channel */</span></span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 从服务器订阅字典中查找关于该频道的所有订阅信息，返回键节点 */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* 从键节点中获取客户端链表 */</span></span><br><span class="line">        clients = dictGetVal(de);</span><br><span class="line">        <span class="comment">/* 从客户端链表中搜索当前退订的客户端 */</span></span><br><span class="line">        ln = listSearchKey(clients,c);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* 将链表节点ln从链表clients中删除 */</span></span><br><span class="line">        listDelNode(clients,ln);</span><br><span class="line">        <span class="comment">/* 如果该频道只有该客户端订阅过，那么删除后客户端链表为空，从服务器订阅字典中删除该频道的信息 */</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;</span><br><span class="line">            dictDelete(server.pubsub_channels,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果要求通知，则通知客户端 */</span></span><br><span class="line">    <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</span><br><span class="line">        addReply(c,shared.unsubscribebulk);</span><br><span class="line">        addReplyBulk(c,channel);</span><br><span class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</span><br><span class="line">                       listLength(c-&gt;pubsub_patterns));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退订函数虽然长了点，但是还是蛮好理解的，仅仅是将客户端和频道的关联信息从订阅字典中删除</p>
<h1 id="普通订阅的信息发布"><a href="#普通订阅的信息发布" class="headerlink" title="普通订阅的信息发布"></a>普通订阅的信息发布</h1><p>Redis的发布功能由PUBLISH命令实现，底层由pubsubPublishMessage函数实现，该函数向订阅特定频道的所有客户端发送消息。订阅分两种，一个是普通订阅(如上)，另一个是模式订阅，所以函数中也分为向普通订阅的客户端发送消息和向模式订阅的客户端发送消息。因为还没有接触模式订阅，所以先看普通订阅的发布好了</p>
<p>普通订阅的发送消息仅仅是在服务器的订阅字典中寻找特定频道的所有订阅者，依次将消息发送就完成了，比较简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* 发送通知信息 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * channel : 通知信息</span></span><br><span class="line"><span class="comment"> * message : 事件名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> receivers = <span class="number">0</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 服务器的订阅字典保存着所有频道和它的所有订阅者 */</span></span><br><span class="line">    <span class="comment">/* 从该字典中查找频道channel的订阅者，返回键节点 */</span></span><br><span class="line">    de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">/* 从键节点中获取订阅该频道的客户端链表 */</span></span><br><span class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = dictGetVal(de); </span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将迭代器方向设置为从头到尾 */</span></span><br><span class="line">        listRewind(<span class="built_in">list</span>,&amp;li);</span><br><span class="line">        <span class="comment">/* 遍历客户端链表的所有客户端，发送通知信息 */</span></span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            client *c = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</span><br><span class="line">            addReply(c,shared.messagebulk);</span><br><span class="line">            addReplyBulk(c,channel);</span><br><span class="line">            addReplyBulk(c,message);</span><br><span class="line">            receivers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模式订阅"><a href="#模式订阅" class="headerlink" title="模式订阅"></a>模式订阅</h1><p>Redis允许客户端使用正则表达式订阅一组频道，命令格式为PSUBSCRIBE [频道名]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PSUBSCRIBE <span class="string">"news.redi[xy]"</span>	<span class="comment">//订阅"news.redix"和"news.rediy"两个频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span>	<span class="comment">//命令关键字</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"news.redi[xy]"</span>	<span class="comment">//频道名</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span>	<span class="comment">//订阅该频道的客户端数量</span></span><br></pre></td></tr></table></figure>
<p>此时，如果打开另一个客户端，不管是向news.redix频道发送还是向news.rediy频道发送消息，上面这个客户端都会接收到消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PUBLISH <span class="string">"news.redix"</span> <span class="string">"send to news.redix"</span>	<span class="comment">//向"news.redix"频道发送消息</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PUBLISH <span class="string">"news.rediy"</span> <span class="string">"send to news.rediy"</span>	<span class="comment">//向"news.rediy"频道发送消息</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PSUBSCRIBE <span class="string">"news.redi[xy]"</span>	<span class="comment">//订阅"news.redix"和"news.rediy"两个频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"news.redi[xy]"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span>		<span class="comment">//从频道news.redix接收到消息</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"news.redi[xy]"</span>	</span><br><span class="line"><span class="number">3</span>) <span class="string">"news.redix"</span>		<span class="comment">//频道名</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"send to news.redix"</span>	<span class="comment">//消息内容</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"pmessage"</span>		<span class="comment">//从频道news.rediy接收到消息</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"news.redi[xy]"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"news.rediy"</span>		<span class="comment">//频道名</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"send to news.rediy"</span> <span class="comment">//消息内容</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下将用正则表达式表示的频道称为频道组，如”news.redi[xy]”就是一个频道组</p>
</blockquote>
<h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><p>由于模式订阅的频道名代表一组频道，所以不能用字典存储，因为字典的键是已知的，当然可以将用正则表达式代表的频道的所有可能都计算处然后添加到字典中，不过Redis不会这么做，论谁谁都不会，因为结果集太大了。</p>
<p>所以字典在这里算是没有用武之地了，Redis采用链表将每个客户端和它订阅的频道组记录起来，每当向特定频道发布消息时，Redis就会遍历这个链表判断每个客户端的频道组是否可以和当前频道匹配，如果匹配则向该客户端发送消息。当然，每个客户端也有这么个链表记录自己订阅的频道组，在它们的定义中可以清楚的看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    dict *pubsub_channels; 	<span class="comment">//订阅字典</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">//模式订阅链表</span></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    dict *pubsub_channels; 	<span class="comment">//订阅字典</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">//模式订阅链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与订阅字典相同，模式订阅链表在客户端和服务器的作用也不相同</p>
<ul>
<li>客户端的模式订阅链表保存当前客户端订阅的所有频道组</li>
<li>服务器的模式订阅链表保存所有客户端订阅的所有频道组(链表中可能有多个节点指向的客户端相同，但是频道组不同)</li>
</ul>
<p>客户端链表的节点保存的是频道组</p>
<p>服务器链表的节点保存的结构是pubsubPattern类型，该结构记录着客户端和一个频道组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    client *client; <span class="comment">//客户端</span></span><br><span class="line">    robj *pattern;  <span class="comment">//频道组</span></span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>
<p>有了订阅模块的基础，到这里可以猜测模式订阅也仅仅是将客户端和其模式订阅的频道组组成pubsubPattern添加到服务器的模式订阅链表中，将频道组添加到客户端的模式订阅链表中，并不做其他处理</p>
<h2 id="模式订阅功能"><a href="#模式订阅功能" class="headerlink" title="模式订阅功能"></a>模式订阅功能</h2><p>事实也正是如此，模式订阅功能由pubsubSubscribePattern函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* 模式订阅 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribePattern</span><span class="params">(client *c, robj *pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从客户端的模式订阅链表中查找要订阅的模式，如果不存在，才进行添加 */</span></span><br><span class="line">    <span class="keyword">if</span> (listSearchKey(c-&gt;pubsub_patterns,pattern) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* pubsubPattern结构记录着客户端c和频道组pattern */</span></span><br><span class="line">        pubsubPattern *pat;</span><br><span class="line">        <span class="comment">/* 将频道组添加到客户端模式订阅链表尾部 */</span></span><br><span class="line">        listAddNodeTail(c-&gt;pubsub_patterns,pattern);</span><br><span class="line">        incrRefCount(pattern);</span><br><span class="line">        <span class="comment">/* 申请空间，组装pubsubPattern结构 */</span></span><br><span class="line">        pat = zmalloc(<span class="keyword">sizeof</span>(*pat));</span><br><span class="line">        pat-&gt;pattern = getDecodedObject(pattern);</span><br><span class="line">        pat-&gt;client = c;</span><br><span class="line">        <span class="comment">/* 将订阅节点添加到服务器的订阅链表中 */</span></span><br><span class="line">        listAddNodeTail(server.pubsub_patterns,pat);</span><br><span class="line">        <span class="comment">/* 因为客户端的订阅链表只需要记录自己订阅频道组即可，所以无需存储pubsubPattern结构</span></span><br><span class="line"><span class="comment">         * 而服务器需要记录每个客户端和其频道组，二者都需要记录，所以存储pubsubPattern结构 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</span><br><span class="line">    addReply(c,shared.psubscribebulk);</span><br><span class="line">    addReplyBulk(c,pattern);</span><br><span class="line">    addReplyLongLong(c,clientSubscriptionsCount(c));</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模式退订功能"><a href="#模式退订功能" class="headerlink" title="模式退订功能"></a>模式退订功能</h2><p>退订和订阅是相反的，对于模式订阅的退订也是如此，仅仅是将频道组从模式订阅链表中删除，需要注意的是要退订就退订整个频道组，Redis不支持将特定频道从频道组中去除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* 退订模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribePattern</span><span class="params">(client *c, robj *pattern, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    pubsubPattern pat;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    incrRefCount(pattern); <span class="comment">/* Protect the object. May be the same we remove */</span></span><br><span class="line">    <span class="comment">/* 从客户端自己的模式订阅链表中查找相应模式 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ln = listSearchKey(c-&gt;pubsub_patterns,pattern)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 如果找到，则删除链表节点 */</span></span><br><span class="line">        listDelNode(c-&gt;pubsub_patterns,ln);</span><br><span class="line">        pat.client = c;</span><br><span class="line">        pat.pattern = pattern;</span><br><span class="line">        <span class="comment">/* 从服务器的模式订阅链表中查找，然后删除 */</span></span><br><span class="line">        ln = listSearchKey(server.pubsub_patterns,&amp;pat);</span><br><span class="line">        listDelNode(server.pubsub_patterns,ln);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</span><br><span class="line">        addReply(c,shared.punsubscribebulk);</span><br><span class="line">        addReplyBulk(c,pattern);</span><br><span class="line">        addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+</span><br><span class="line">                       listLength(c-&gt;pubsub_patterns));</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(pattern);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模式订阅的信息发布"><a href="#模式订阅的信息发布" class="headerlink" title="模式订阅的信息发布"></a>模式订阅的信息发布</h1><p>最后一个就是关于向模式订阅发布消息的实现了，在上面订阅模块处，仅仅看到了pubsubPublishMessage函数向订阅特定频道的客户端发送消息。而实际上，它还有一部分是向模式订阅的客户端发送消息，方法是遍历模式订阅链表，对于每一个节点判断其频道组是否和当前频道匹配，如果匹配，则向客户端发送消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pubsub.c</span></span><br><span class="line"><span class="comment">/* 发送通知信息 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * channel : 通知信息</span></span><br><span class="line"><span class="comment"> * message : 事件名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> receivers = <span class="number">0</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">	</span><br><span class="line">	... <span class="comment">//这里省略普通订阅的发布功能</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 查找模式订阅的客户端 */</span></span><br><span class="line">    <span class="comment">/* 这里就体现了为什么订阅频道和客户端是用字典存储，而模式订阅则用链表存储 </span></span><br><span class="line"><span class="comment">     * 因为订阅可以直接使用哈希表定位，而模式订阅类似正则匹配，需要判断当前的频道是否</span></span><br><span class="line"><span class="comment">     * 是匹配的模式订阅，然后发送给订阅者，哈希表在这里是没有作用的 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.pubsub_patterns)) &#123;</span><br><span class="line">        <span class="comment">/* 迭代器方向设置为从头到尾 */</span></span><br><span class="line">        listRewind(server.pubsub_patterns,&amp;li);</span><br><span class="line">        channel = getDecodedObject(channel);</span><br><span class="line">        <span class="comment">/* 遍历服务器的模式订阅链表 */</span></span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* 获取每个节点的频道组 */</span></span><br><span class="line">            pubsubPattern *pat = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断频道组是否和当前频道匹配，如果匹配，则发送通知信息 */</span></span><br><span class="line">            <span class="keyword">if</span> (stringmatchlen((<span class="keyword">char</span>*)pat-&gt;pattern-&gt;ptr,</span><br><span class="line">                                sdslen(pat-&gt;pattern-&gt;ptr),</span><br><span class="line">                                (<span class="keyword">char</span>*)channel-&gt;ptr,</span><br><span class="line">                                sdslen(channel-&gt;ptr),<span class="number">0</span>)) &#123;</span><br><span class="line">                addReply(pat-&gt;client,shared.mbulkhdr[<span class="number">4</span>]);</span><br><span class="line">                addReply(pat-&gt;client,shared.pmessagebulk);</span><br><span class="line">                addReplyBulk(pat-&gt;client,pat-&gt;pattern);</span><br><span class="line">                addReplyBulk(pat-&gt;client,channel);</span><br><span class="line">                addReplyBulk(pat-&gt;client,message);</span><br><span class="line">                receivers++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于模式订阅，Redis会使用stringmatchlen函数进行正则匹配，如果匹配成功，说明该客户端关注的频道组中包含当前频道，那么就需要将消息发送给客户端</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇注意是对Redis订阅与发布功能的分析，源码比较简单，对于订阅功能，仅仅是将客户端和频道名(组)记录在某个数据结构中，当有其他客户端向某个频道执行发布功能时，检查数据结构中那些订阅了该频道的客户端，并向其发送消息</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/04/Redis源码剖析（四）过期键的删除策略/" rel="next" title="Redis源码剖析（四）过期键的删除策略">
                <i class="fa fa-chevron-left"></i> Redis源码剖析（四）过期键的删除策略
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/06/Redis源码剖析（六）事务模块/" rel="prev" title="Redis源码剖析（六）事务模块">
                Redis源码剖析（六）事务模块 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/rocwangp" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://blog.csdn.net/sinat_35261315" target="_blank" title="CSDN"><i class="fa fa-fw fa-globe"></i>CSDN</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#普通订阅"><span class="nav-number">1.</span> <span class="nav-text">普通订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储结构"><span class="nav-number">1.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#订阅功能"><span class="nav-number">1.2.</span> <span class="nav-text">订阅功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#退订功能"><span class="nav-number">1.3.</span> <span class="nav-text">退订功能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#普通订阅的信息发布"><span class="nav-number">2.</span> <span class="nav-text">普通订阅的信息发布</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模式订阅"><span class="nav-number">3.</span> <span class="nav-text">模式订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储结构-1"><span class="nav-number">3.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模式订阅功能"><span class="nav-number">3.2.</span> <span class="nav-text">模式订阅功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模式退订功能"><span class="nav-number">3.3.</span> <span class="nav-text">模式退订功能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模式订阅的信息发布"><span class="nav-number">4.</span> <span class="nav-text">模式订阅的信息发布</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  
  

  
  

  


  
  

  

  

  

  

</body>
</html>
